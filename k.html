<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Weirdther</title>
<script src="weirdther-core.js"></script>
<script src="weather-icons-eink.js"></script>
<style>
body { margin: 0; padding: 0; background: white; color: black; }
#wrapper { padding: 18px 22px; font-family: Helvetica, Arial, sans-serif; -webkit-box-sizing: border-box; box-sizing: border-box; overflow: hidden; }
#header { font-size: 42px; padding-bottom: 6px; border-bottom: 3px solid black; margin-bottom: 10px; }
.hdr-row { border: none; width: 100%; }
.hdr-row td { border: none; padding: 0; font-size: 42px; }
.hdr-right { text-align: right; white-space: nowrap; width: 1px; }
#loading { font-size: 48px; padding: 30px 0; }
#error { font-size: 48px; font-weight: bold; }
.progress-container { width: 100%; height: 60px; background: #ddd; border: 2px solid black; margin: 20px 0; position: relative; }
.progress-bar { height: 100%; background: black; width: 0%; transition: width 0.3s ease; }
.progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 36px; font-weight: bold; color: #333; }
/* Vars + Score side by side */
.vars-row { border: none; width: 100%; margin: 0; }
.vars-row td { border: none; padding: 0; vertical-align: top; }
.score-box { text-align: right; white-space: nowrap; padding-left: 12px; }
.score-num { font-size: 156px; font-weight: bold; line-height: 1; padding: 0 6px; }
.score-lbl { font-size: 66px; font-weight: bold; letter-spacing: 2px; padding: 0 6px; }
.score-num-inv { font-size: 156px; font-weight: bold; line-height: 1; padding: 0 6px; color: white; background: black; display: inline-block; }
.score-weirdther { font-size: 48px;}
.score-freq { font-size: 48px; color: #333; }
/* Variable breakdown */
table.vars { border-collapse: collapse; width: 100%; margin: 0; }
table.vars td { border: none; padding: 2px 6px; font-size: 52px; }
table.vars .vi { font-size: 54px; text-align: center; width: 56px; }
table.vars .pct { color: #333; text-align: right; }
table.vars .bld td { font-weight: bold; color: white; background: black; }
table.vars .bld-lo td { font-weight: bold; color: white; background: gray; }
/* Section labels */
.section-label { font-size: 26px; font-weight: bold; color: #666; letter-spacing: 2px; text-transform: uppercase; padding: 6px 0 3px; border-bottom: 1px solid #bbb; margin-bottom: 6px; }
/* Outer card */
.weather-card { border: 2px solid black; padding: 10px 14px; margin-bottom: 0; }
/* Hourly timeline */
table.fc-hourly { border-collapse: collapse; width: 100%; margin-bottom: 0; border: none; border-top: 1px solid #ccc; }
table.fc-hourly td { text-align: center; padding: 4px 1px; border-left: 1px solid #ccc; font-size: 30px; vertical-align: top; }
table.fc-hourly td:first-child { border-left: none; }
.h-icon svg { width: 52px !important; height: 52px !important; }
.h-past { opacity: 0.3; }
.h-rain { font-weight: bold; }
.h-prob { color: #555; }
.h-wet td { background: #ddd; }
/* Forecast icon strip */
table.fc-strip { border-collapse: collapse; width: 100%; margin-bottom: 0; border: none; }
table.fc-strip td { text-align: center; padding: 6px 4px; border-left: 1px solid #ccc; vertical-align: top; font-size: 40px; }
table.fc-strip td:first-child { border-left: none; }
table.fc-strip a { color: black; text-decoration: none; display: block; }
.strip-day-name { font-size: 34px; font-weight: bold; }
.strip-icon svg { width: 72px !important; height: 72px !important; }
.strip-temps { font-size: 34px; white-space: nowrap; }
.strip-temps .strip-lo { color: #555; }
.strip-selected { background: #eee; padding-left: 14px !important; padding-right: 14px !important; }
table.fc-strip .bld { font-weight: bold; color: white; background: black; }
table.fc-strip .bld-lo { font-weight: bold; color: white; background: gray; }
table.fc-strip .strip-selected.bld { background: black; }
table.fc-strip .strip-selected.bld-lo { background: gray; }
.strip-icon-col { text-align: right; padding-right: 6px !important; border-left: none !important; width: 1px; white-space: nowrap; }
.strip-icon-col svg { width: 36px !important; height: 36px !important; }
.strip-w-lbl { font-size: 32px; font-weight: bold; }
.strip-pct { font-size: 0.55em; color: inherit; }
/* Forecast table */
table.fc { border-collapse: collapse; width: 100%; border: none; border-top: 1px solid #ccc; }
table.fc th, table.fc td { border: none; padding: 5px 7px; text-align: right; font-size: 40px; }
table.fc th { background: #ddd; color: black; font-size: 36px; }
table.fc th:first-child, table.fc td:first-child { width: 1px; white-space: nowrap; padding: 5px 4px; }
table.fc .day-col { text-align: left; }
table.fc .icon-col { text-align: center; width: 52px; padding: 4px 2px; }
.hdr-right .icon-col { display: inline-block; vertical-align: middle; }
table.fc .bld { font-weight: bold; color: white; background: black; }
table.fc .bld-lo { font-weight: bold; color: white; background: gray; }
table.fc a { color: black; text-decoration: underline; }
/* Header controls */
.loc-form { margin: 0; padding: 0; width: 100%; white-space: nowrap; }
.loc-input { width: calc(100% - 80px); font-size: 36px; border: 1px solid gray; padding: 2px 6px; -webkit-box-sizing: border-box; box-sizing: border-box; vertical-align: top; }
.go-btn { width: 70px; font-size: 36px; border: 1px solid gray; padding: 2px 8px; vertical-align: top; margin-left: -4px; }
.score-refresh { font-size: 36px; color: #555; }
</style>
</head>
<body>
<div id="wrapper">
<div id="header"></div>
<div id="loading"></div>
<div id="error"></div>
<div id="results"></div>
</div>

<script>
/* ========== CONFIGURATION ========== */
var VAR_LIST = WEIRDTHER_CONFIG.DAILY_VARS.split(",");
var DEFAULT_DELTA = 5;
var NUM_FORECAST_DAYS = 6;
var HISTORICAL_YEARS = 26;
var SCORE_VARS = WEIRDTHER_CONFIG.SCORE_VARS;
/* FRIENDLY is derived from FRIENDLY_NAMES (weirdther-core.js). Overrides
   use shorter names and &deg; entities for e-ink legibility. */
var FRIENDLY_OVERRIDES = {
    "temperature_2m_max": {name: "Max", metric: "&deg;C", imperial: "&deg;F"},
    "temperature_2m_min": {name: "Min", metric: "&deg;C", imperial: "&deg;F"},
    "rain_sum":           {metric: "mm", imperial: "in"},
    "snowfall_sum":       {metric: "mm", imperial: "in"},
    "wind_speed_10m_max": {metric: "km/h", imperial: "mph"},
    "sunshine_duration":  {name: "Sun", metric: "%", imperial: "%"}
};
var FRIENDLY = {};
for (var _vn in FRIENDLY_NAMES) {
    if (!FRIENDLY_NAMES.hasOwnProperty(_vn)) continue;
    var _ov = FRIENDLY_OVERRIDES[_vn] || {};
    FRIENDLY[_vn] = {
        name:     _ov.name     !== undefined ? _ov.name     : FRIENDLY_NAMES[_vn].name,
        lower:    FRIENDLY_NAMES[_vn].lower,
        higher:   FRIENDLY_NAMES[_vn].higher,
        metric:   _ov.metric   !== undefined ? _ov.metric   : FRIENDLY_NAMES[_vn].metric_short,
        imperial: _ov.imperial !== undefined ? _ov.imperial : FRIENDLY_NAMES[_vn].imperial_short
    };
}

var VAR_ICONS = {
    "temperature_2m_max": "&#9650;",
    "temperature_2m_min": "&#9660;",
    "rain_sum": "&#9730;",
    "snowfall_sum": "&#9731;",
    "wind_speed_10m_max": "&#8776;",
    "sunshine_duration": "&#9728;"
};

var currentLat = null;
var currentLon = null;
var currentUnits = "metric";
var currentDateStr = "";
var locationName = "";

/* ========== CACHE ========== */

function getDefaultUnit() {
    if (!useCache) {
        var locale = navigator.language || navigator.userLanguage || "-";
        var country = locale.split('-')[1] || locale;
        var imperialCountries = ['US', 'LR', 'MM'];
        return imperialCountries.indexOf(country.toUpperCase()) !== -1 ? 'imperial' : 'metric';
    }
    try {
        var storedUnit = localStorage.getItem('unit');
        if (storedUnit) return storedUnit;
    } catch (e) {}
    var locale = navigator.language || navigator.userLanguage || "-";
    var country = locale.split('-')[1] || locale;
    var imperialCountries = ['US', 'LR', 'MM'];
    return imperialCountries.indexOf(country.toUpperCase()) !== -1 ? 'imperial' : 'metric';
}

function setDefaultUnit(unit) {
    if (!useCache) return;
    try {
        localStorage.setItem('unit', unit);
    } catch (e) {}
}


/* ========== UTILITY ========== */

// parseUrlParams is provided by weirdther-core.js

function windArrowSvg(dirDeg, speedKmh) {
    var norm = Math.pow(Math.min(speedKmh || 0, 80) / 80, 0.6); // power curve — low speeds stay small
    var size = Math.round(18 + norm * 62);  // 18–80px
    var sw   = (1.0 + norm * 6.0).toFixed(1); // 1.0–7.0
    return '<svg viewBox="0 0 24 24" width="' + size + '" height="' + size + '" fill="none">' +
        '<g transform="rotate(' + Math.round(dirDeg || 0) + ',12,12)">' +
        '<line x1="12" y1="21" x2="12" y2="7" stroke="currentColor" stroke-width="' + sw + '" stroke-linecap="round"/>' +
        '<polygon points="12,2 7.5,9 16.5,9" fill="currentColor"/>' +
        '</g></svg>';
}

function showProgress(message, percent) {
    var el = document.getElementById("loading");
    if (!el) return;
    var pct = Math.round(percent);
    el.innerHTML = '<div>' + message + '</div>' +
        '<div class="progress-container">' +
        '<div class="progress-bar" style="width: ' + pct + '%"></div>' +
        '</div>';
    el.style.display = "";
}

function formatDateShort(dateStr) {
    var d = parseDate(dateStr);
    var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    return days[d.getDay()] + " " + d.getDate() + " " + months[d.getMonth()];
}


/* ========== API ========== */

/* fetchForecast, fetchHistoricalRange, fetchHistoricalYear, fetchAllHistorical,
   mergeForecastHistorical are provided by weirdther-core.js */

/* ========== DATA PROCESSING ========== */

function allZero(arr) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] != null && arr[i] > 0) return false;
    }
    return true;
}


function computeAllDayScores(forecastDaily, todayIndex, numDays, historicalGrouped, latitude, units, delta, climateNormal) {
    delta = delta || WEIRDTHER_CONFIG.DEFAULT_DELTA;
    climateNormal = climateNormal || {start: 2000, end: 2030};

    var allScores = [];
    for (var d = 0; d < numDays; d++) {
        var idx = todayIndex + d;
        if (idx >= forecastDaily.time.length) break;

        var ds = {
            date: forecastDaily.time[idx],
            tempMax: forecastDaily.temperature_2m_max[idx],
            tempMin: forecastDaily.temperature_2m_min[idx],
            rain: forecastDaily.rain_sum[idx] || 0,
            snow: forecastDaily.snowfall_sum[idx] || 0,
            wind: forecastDaily.wind_speed_10m_max[idx] || 0,
            sunshinePct: forecastDaily.sunshine_duration[idx] || 0,
            weirdther: 0,
            maxPercentile: 0.5,
            vars: {}
        };

        if (ds.tempMax == null || ds.tempMin == null) continue;

        var varScores = [];
        var maxPctile = 0.5;

        for (var v = 0; v < SCORE_VARS.length; v++) {
            var varName = SCORE_VARS[v];
            var curVal = forecastDaily[varName][idx];
            if (curVal == null) continue;

            // Filter historical data by day-of-year window and climate normal years
            var filtered = filterHistoricalByDateWindow(
                historicalGrouped[varName],
                historicalGrouped["time"],
                ds.date,
                delta,
                climateNormal
            );

            var result = computeVariableScore(varName, filtered.values, filtered.dates, curVal, ds.date, latitude);

            if (filtered.values.length === 0) continue;

            var pctile = result.percentile;
            var score = result.score;

            var qualifier = "";
            if (pctile < 0) qualifier = FRIENDLY[varName].lower + "!";
            else if (pctile > 1) qualifier = FRIENDLY[varName].higher + "!";
            else if (pctile < 0.05) qualifier = "very " + FRIENDLY[varName].lower;
            else if (pctile > 0.95) qualifier = "very " + FRIENDLY[varName].higher;
            else if (pctile < 0.25) qualifier = FRIENDLY[varName].lower;
            else if (pctile > 0.75) qualifier = FRIENDLY[varName].higher;

            var dispPctile = pctile;
            if (dispPctile < 0) dispPctile = 0;
            if (dispPctile > 1) dispPctile = 1;

            var dispValue = curVal;
            if (varName === "sunshine_duration") dispValue = ds.sunshinePct;

            ds.vars[varName] = {
                raw: dispPctile,
                score: score,
                qualifier: qualifier,
                value: dispValue
            };

            if (isScoreVar(varName)) {
                varScores.push({ varName: varName, score: score });
                var absPctile = Math.abs(pctile - 0.5) + 0.5;
                if (absPctile > maxPctile) maxPctile = absPctile;
            }
        }

        ds.weirdther = computeFinalWeirdtherScore(varScores);
        ds.maxPercentile = maxPctile;
        allScores.push(ds);
    }
    return allScores;
}

/* ========== RENDERING ========== */


function buildPageUrl(overrides) {
    var params = parseUrlParams();
    var keys = ["location", "latitude", "longitude", "units", "date", "rotation", "scale"];
    var i, k;
    for (i = 0; i < keys.length; i++) {
        k = keys[i];
        if (overrides[k] !== undefined) params[k] = overrides[k];
    }

    var qs = buildUrlQuery(params, keys);
    return window.location.pathname + qs;
}

function parseCoords(str) {
    var m = str.trim().match(/^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/);
    if (!m) return null;
    var lat = parseFloat(m[1]), lon = parseFloat(m[2]);
    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
    return {lat: lat, lon: lon};
}

function goLocation() {
    var inp = document.getElementById("loc-input");
    if (!inp || !inp.value) return;
    var coords = parseCoords(inp.value);
    if (coords) {
        window.location.href = buildPageUrl({"latitude": coords.lat, "longitude": coords.lon, "location": "", "date": ""});
    } else {
        window.location.href = buildPageUrl({"location": inp.value, "latitude": "", "longitude": "", "date": ""});
    }
}

function formatTime(d) {
    var h = d.getHours();
    var m = d.getMinutes();
    var day = d.getDate();
    var month = d.getMonth() + 1;
    var year = d.getFullYear();
    return year + "-" + (month < 10 ? "0" : "") + month + "-" + (day < 10 ? "0" : "") + day + " " +
           (h < 10 ? "0" : "") + h + ":" + (m < 10 ? "0" : "") + m;
}

function buildDateLink(dateStr) {
    var params = parseUrlParams();
    params.date = dateStr;
    var keys = ["location", "latitude", "longitude", "units", "rotation", "scale", "date"];
    return buildUrlQuery(params, keys);
}

function fmtVal(varName, value, units) {
    if (varName === "sunshine_duration") return Math.round(value) + "%";
    if (varName === "temperature_2m_max" || varName === "temperature_2m_min") return Math.round(value) + FRIENDLY[varName][units];
    if (varName === "wind_speed_10m_max") return Math.round(value) + FRIENDLY[varName][units];
    return (value != null ? value.toFixed(1) : "0") + FRIENDLY[varName][units];
}

function renderAll(dayScores, units, startYear, endYear, hideVars, selectedDate, weatherCodes, currentWeather, hourlyData) {
    weatherCodes = weatherCodes || {};
    var html = "";
    var nowStr = toISODate(new Date());

    // Find the selected day in dayScores (may not be index 0 if yesterday is included)
    var selectedIdx = 0;
    for (var si = 0; si < dayScores.length; si++) {
        if (dayScores[si].date === selectedDate) { selectedIdx = si; break; }
    }
    var today = dayScores[selectedIdx];

    var isToday = (today.date === nowStr);
    var todayWxCode = weatherCodes[today.date];
    var wxIcon = '<span class="icon-col" title="' + (todayWxCode != null ? weatherCodeToDescription(todayWxCode) : "") + '">' + getWeatherIconEink(todayWxCode) + '</span>' 
    var dateLabel = isToday ? "Today" : formatDateShort(today.date);

    /* ---- Update header: location input left, units+weather right ---- */
    var escapedName = locationName.replace(/"/g, '&quot;');
    var metricUrl = buildPageUrl({"units": "metric"});
    var imperialUrl = buildPageUrl({"units": "imperial"});
    var unitC = units === "metric" ? "<b>C</b>" : '<a href="' + metricUrl + '">C</a>';
    var unitF = units === "imperial" ? "<b>F</b>" : '<a href="' + imperialUrl + '">F</a>';
    var _now = new Date();
    var _timeStr = (_now.getHours() < 10 ? "0" : "") + _now.getHours() + ":" + (_now.getMinutes() < 10 ? "0" : "") + _now.getMinutes();
    show("header", '<table class="hdr-row"><tr>' +
        '<td><form onsubmit="goLocation();return false;" class="loc-form"><input id="loc-input" class="loc-input" value="' + escapedName + '"><input type="submit" value="Go" class="go-btn"></form></td>' +
        '<td class="hdr-right">' + unitC + '|' + unitF + ' <span class="score-refresh">' + _timeStr + '</span></td>' +
        '</tr></table>');

    /* ---- 3-hourly rain timeline for selected day ---- */
    if (hourlyData) {
        //html += '<div class="section-label">Hourly</div>';
        var SLOTS = [0, 3, 6, 9, 12, 15, 18, 21];
        var nowHour = isToday ? new Date().getHours() : -1;
        var anySlot = false;
        var slotRows = [];
        for (var si = 0; si < SLOTS.length; si++) {
            var slotH = SLOTS[si];
            var pad = slotH < 10 ? "0" : "";
            var timeKey = selectedDate + "T" + pad + slotH + ":00";
            var hidx = hourlyData.time.indexOf(timeKey);
            if (hidx === -1) continue;
            anySlot = true;
            var hWxCode   = hourlyData.weather_code[hidx];
            var hProb     = hourlyData.precipitation_probability[hidx] || 0;
            var hPrecip   = hourlyData.precipitation[hidx] || 0;
            var hSnow     = hourlyData.snowfall[hidx] || 0;
            var hTemp     = hourlyData.temperature_2m[hidx];
            var hWindKmh  = hourlyData.wind_speed_10m ? (hourlyData.wind_speed_10m[hidx] || 0) : 0;
            var hWindDir  = hourlyData.wind_direction_10m ? (hourlyData.wind_direction_10m[hidx] || 0) : 0;
            var isPast    = (nowHour >= 0 && slotH < nowHour);
            var isWet     = hPrecip > 0 || hSnow > 0;
            var tempStr   = units === "imperial" ? Math.round(hTemp * 9/5 + 32) + "&deg;" : Math.round(hTemp) + "&deg;";
            var precipStr = "";
            if (isWet) {
                if (units === "imperial") {
                    precipStr = hSnow > 0 ? (hSnow * 0.393701).toFixed(1) + '"' : (hPrecip * 0.0393701).toFixed(2) + '"';
                } else {
                    precipStr = hSnow > 0 ? hSnow.toFixed(1) + "cm" : hPrecip.toFixed(1) + "mm";
                }
            }
            var windSpeedDisp = units === "imperial" ? Math.round(hWindKmh * 0.621371) + " mph" : Math.round(hWindKmh) + " km/h";
            slotRows.push({slotH: slotH, hWxCode: hWxCode, hProb: hProb, tempStr: tempStr, precipStr: precipStr, isWet: isWet, isPast: isPast, hWindKmh: hWindKmh, hWindDir: hWindDir, windSpeedDisp: windSpeedDisp});
        }
        if (anySlot || (isToday && currentWeather)) {
            html += '<table class="fc-hourly"><tr>';
            /* "Now" cell from current weather when viewing today */
            if (isToday && currentWeather) {
                var cw = currentWeather;
                var cwTempStr = units === "imperial" ? Math.round(cw.temperature_2m * 9/5 + 32) + "&deg;" : Math.round(cw.temperature_2m) + "&deg;";
                var cwFeelStr = units === "imperial" ? Math.round(cw.apparent_temperature * 9/5 + 32) + "&deg;" : Math.round(cw.apparent_temperature) + "&deg;";
                var cwPrecip  = cw.precipitation || 0;
                var cwPrecipStr = "";
                if (cwPrecip > 0) {
                    cwPrecipStr = units === "imperial" ? (cwPrecip * 0.0393701).toFixed(2) + '"' : cwPrecip.toFixed(1) + "mm";
                }
                var cwWindKmh = cw.wind_speed_10m || 0;
                var cwWindDir = cw.wind_direction_10m || 0;
                var cwWindDisp = units === "imperial" ? Math.round(cwWindKmh * 0.621371) + " mph" : Math.round(cwWindKmh) + " km/h";
                html += '<td>';
                html += '<div><b>Now</b></div>';
                html += '<div class="h-icon">' + getWeatherIconEink(cw.weather_code) + '</div>';
                html += '<div>' + cwTempStr + '</div>';
                html += '<div class="h-prob">' + cwFeelStr + '</div>';
                html += '<div class="h-rain">' + (cwPrecipStr || '&nbsp;') + '</div>';
                html += '<div class="h-wind" title="' + cwWindDisp + '">' + windArrowSvg(cwWindDir, cwWindKmh) + '</div>';
                html += '</td>';
            }
            for (var sr = 0; sr < slotRows.length; sr++) {
                var row = slotRows[sr];
                if (isToday && currentWeather && row.isPast) continue;
                var tdClass = row.isWet ? ' class="h-wet"' : '';
                html += '<td' + tdClass + '>';
                html += '<div>' + (row.slotH < 10 ? "0" : "") + row.slotH + 'h</div>';
                html += '<div class="h-icon">' + getWeatherIconEink(row.hWxCode) + '</div>';
                html += '<div>' + row.tempStr + '</div>';
                html += '<div class="h-prob">' + (row.hProb > 0 ? row.hProb + '%' : '&nbsp;') + '</div>';
                html += '<div class="h-rain">' + (row.precipStr || '&nbsp;') + '</div>';
                html += '<div class="h-wind" title="' + row.windSpeedDisp + '">' + windArrowSvg(row.hWindDir, row.hWindKmh) + '</div>';
                html += '</td>';
            }
            html += '</tr></table>';
        }
    }

    /* ---- Forecast grid (bottom): vars as rows, days as columns ---- */
    //html += '<div class="section-label">Forecast</div>';
    html += '<table class="fc-strip">';

    /* Row 0: day names + weather icons */
    html += '<tr><td class="strip-icon-col"></td>';
    for (var sd = 0; sd < dayScores.length; sd++) {
        var sds = dayScores[sd];
        var sLink = buildDateLink(sds.date);
        var sLabel = (sds.date === nowStr) ? "Today" : formatDateShort(sds.date).split(" ")[0];
        var selAttr = (sds.date === selectedDate) ? ' class="strip-selected"' : '';
        html += '<td' + selAttr + '><a href="' + sLink + '">';
        html += '<div class="strip-day-name">' + sLabel + '</div>';
        html += '<div class="strip-icon">' + getWeatherIconEink(weatherCodes[sds.date]) + '</div>';
        html += '</a></td>';
    }
    html += '</tr>';

    /* Helper: build class attr for a data cell */
    function gridCellAttr(isSel, cls) {
        var c = (isSel ? "strip-selected" : "") + (cls ? (isSel ? " " : "") + cls : "");
        return c ? ' class="' + c + '"' : "";
    }

    /* Variable rows */
    var gridRows = [
        { icon: getVarIconEink("temperature_2m_max"), fn: function(s) { return Math.round(s.tempMax) + "&deg;"; },  cls: function(s) { return s.vars["temperature_2m_max"] ? unusualClass(s.vars["temperature_2m_max"].raw) : ""; }, pct: function(s) { return s.vars["temperature_2m_max"] ? pctPretty(s.vars["temperature_2m_max"].raw) : ""; } },
        { icon: getVarIconEink("temperature_2m_min"), fn: function(s) { return Math.round(s.tempMin) + "&deg;"; },  cls: function(s) { return s.vars["temperature_2m_min"] ? unusualClass(s.vars["temperature_2m_min"].raw) : ""; }, pct: function(s) { return s.vars["temperature_2m_min"] ? pctPretty(s.vars["temperature_2m_min"].raw) : ""; } },
        { icon: getVarIconEink("rain_sum"),           fn: function(s) { return (s.snow > 0 ? s.snow : s.rain).toFixed(1); }, cls: function(s) { var vn = s.snow > 0 ? "snowfall_sum" : "rain_sum"; return s.vars[vn] ? unusualClass(s.vars[vn].raw) : ""; }, pct: function(s) { var vn = s.snow > 0 ? "snowfall_sum" : "rain_sum"; return s.vars[vn] ? pctPretty(s.vars[vn].raw) : ""; } },
        { icon: getVarIconEink("wind_speed_10m_max"), fn: function(s) { return units === "imperial" ? Math.round(s.wind * 0.621371) : Math.round(s.wind); }, cls: function(s) { return s.vars["wind_speed_10m_max"] ? unusualClass(s.vars["wind_speed_10m_max"].raw) : ""; }, pct: function(s) { return s.vars["wind_speed_10m_max"] ? pctPretty(s.vars["wind_speed_10m_max"].raw) : ""; } },
        { icon: getVarIconEink("sunshine_duration"),  fn: function(s) { return Math.round(s.sunshinePct); }, cls: function(s) { return s.vars["sunshine_duration"] ? unusualClass(s.vars["sunshine_duration"].raw) : ""; }, pct: function(s) { return s.vars["sunshine_duration"] ? pctPretty(s.vars["sunshine_duration"].raw) : ""; } }
    ];
    for (var gr = 0; gr < gridRows.length; gr++) {
        var row = gridRows[gr];
        html += '<tr><td class="strip-icon-col">' + row.icon + '</td>';
        for (var sd = 0; sd < dayScores.length; sd++) {
            var sds = dayScores[sd];
            var isSel = sds.date === selectedDate;
            var cellVal = row.fn(sds) + '<div class="strip-pct">' + row.pct(sds) + '</div>';
            html += '<td' + gridCellAttr(isSel, row.cls(sds)) + '>' + cellVal + '</td>';
        }
        html += '</tr>';
    }

    /* Weirdther score row */
    html += '<tr><td class="strip-icon-col strip-w-lbl">W</td>';
    for (var sd = 0; sd < dayScores.length; sd++) {
        var sds = dayScores[sd];
        var isSel = sds.date === selectedDate;
        var wCls = sds.weirdther >= 75 ? "bld" : "";
        var wVal = sds.weirdther + '<div class="strip-pct">' + getScoreLabel(sds.weirdther) + '</div>';
        html += '<td' + gridCellAttr(isSel, wCls) + '>' + wVal + '</td>';
    }
    html += '</tr>';

    html += '</table>';

    show("results", html);
}

/* ========== MAIN FLOW ========== */

function loadWeather(lat, lon, units, dateStr) {
    currentLat = lat;
    currentLon = lon;
    currentUnits = units;
    currentDateStr = dateStr;
    var date = parseDate(dateStr);
    var delta = DEFAULT_DELTA;
    var endYear = 2030;  // Match app.js climate normal
    var startYear = 2001;  // Match app.js climate normal

    show("error", "");
    show("results", "");
    show("loading", "Loading forecast...");

    fetchForecast(lat, lon, function(err, forecast) {
        if (err || !forecast || !forecast.daily) {
            show("loading", "");
            show("error", "Error loading forecast: " + (err || "no data"));
            return;
        }

        var forecastCurrent = (forecast.current && forecast.current.temperature_2m != null) ? forecast.current : null;
        var forecastHourly = (forecast.hourly && forecast.hourly.time) ? forecast.hourly : null;

        showProgress("Loading current weather...", 10);

        // Compute the date range to fetch historical data for (covers selected date + forecast days)
        var dayBefore = toISODate(new Date(date.getTime() - 86400000));
        var rangeEndDate = toISODate(new Date(date.getTime() + (NUM_FORECAST_DAYS - 1) * 86400000));
        var forecastStart = dayBefore;
        var forecastEnd = rangeEndDate;
        // Extend range to cover forecast bounds if the selected date is within them
        if (forecast.daily.time[0] < forecastStart) forecastStart = forecast.daily.time[0];
        if (forecast.daily.time[forecast.daily.time.length - 1] > forecastEnd) forecastEnd = forecast.daily.time[forecast.daily.time.length - 1];

        fetchHistoricalRange(lat, lon, forecastStart, forecastEnd, function(err, currentHistorical) {
            showProgress("Loading historical data for comparison...", 30);
            if (!currentHistorical) {
                console.log("Using forecast data for current dates (archive API not available for recent dates)");
            }

            // Use selected date as center, but fetch wider range to cover all forecast dates
            // Each forecast day will use its own ±delta window from this wider dataset
            var widerDelta = delta + NUM_FORECAST_DAYS - 1;  // Cover selected ±delta + all forecast days
            console.log("Historical data: center=" + dateStr + ", widerDelta=" + widerDelta + " (covers all forecast dates " + forecastStart + " to " + forecastEnd + ")");

            fetchAllHistorical(lat, lon, date, widerDelta, startYear, endYear,
                function(done, total) {
                    showProgress("Loading historical data...", 30 + (done / total) * 70);
                },
                function(err, results) {
                    var grouped = groupAllHistorical(results || []);
                    show("loading", "");
                    if (err || !grouped || !grouped.time || grouped.time.length === 0) {
                        show("error", "Error loading historical data.");
                        return;
                    }

                    // Save weather_code from forecast before merge (merge drops non-VAR_LIST fields)
                    var forecastWeatherCodes = {};
                    if (forecast.daily.weather_code) {
                        for (var wi = 0; wi < forecast.daily.time.length; wi++) {
                            forecastWeatherCodes[forecast.daily.time[wi]] = forecast.daily.weather_code[wi];
                        }
                    }

                    // Merge forecast with historical data for current dates
                    var mergedForecast = mergeForecastHistorical(forecast, currentHistorical);

                    // Find selected date in merged data
                    var todayIdx = -1;
                    for (var i = 0; i < mergedForecast.daily.time.length; i++) {
                        if (mergedForecast.daily.time[i] === dateStr) { todayIdx = i; break; }
                    }
                    if (todayIdx === -1) {
                        show("error", "No data available for " + dateStr);
                        return;
                    }

                    /* Hide precip vars only if all zero in forecast AND zero is >= P50 historically */
                    var hideVars = {};
                    var precipVars = ["rain_sum", "snowfall_sum"];
                    for (var pv = 0; pv < precipVars.length; pv++) {
                        var pvn = precipVars[pv];
                        var fcAllZero = true;
                        for (var fi = todayIdx; fi < todayIdx + NUM_FORECAST_DAYS && fi < mergedForecast.daily.time.length; fi++) {
                            if ((mergedForecast.daily[pvn][fi] || 0) > 0) { fcAllZero = false; break; }
                        }
                        if (fcAllZero) {
                            var hist = [];
                            for (var hi = 0; hi < grouped[pvn].length; hi++) {
                                if (grouped[pvn][hi] != null) hist.push(grouped[pvn][hi]);
                            }
                            hist.sort(function(a, b) { return a - b; });
                            var zeroPct = hist.length > 0 ? findPercentileForValue(hist, 0) : 0.5;
                            if (zeroPct[0] >= 0.5) hideVars[pvn] = true;
                        }
                    }

                    var delta = WEIRDTHER_CONFIG.DEFAULT_DELTA;
                    var climateNormal = {start: startYear, end: endYear};
                    console.log("Climate normal range:", climateNormal);
                    console.log("Historical data year range:", grouped.time[0], "to", grouped.time[grouped.time.length - 1]);
                    console.log("Total historical days:", grouped.time.length);
                    // Include yesterday only when selected day is today or in the future
                    var isSelectedTodayOrFuture = (dateStr >= toISODate(new Date()));
                    var startIdx = (isSelectedTodayOrFuture && todayIdx > 0) ? todayIdx - 1 : todayIdx;
                    var numDays = NUM_FORECAST_DAYS + ((isSelectedTodayOrFuture && todayIdx > 0) ? 1 : 0);
                    console.log("Score computation: dateStr=" + dateStr + ", todayIdx=" + todayIdx + ", startIdx=" + startIdx + ", numDays=" + numDays + ", isSelectedTodayOrFuture=" + isSelectedTodayOrFuture);
                    console.log("Merged forecast dates:", mergedForecast.daily.time);
                    // Convert to imperial if needed (both forecast and historical so percentiles stay consistent)
                    if (units === "imperial") {
                        convertToImperial(mergedForecast.daily);
                        convertToImperial(grouped);
                    }
                    convertSunshineToPct(mergedForecast.daily);
                    convertSunshineToPct(grouped);

                    var scores = computeAllDayScores(mergedForecast.daily, startIdx, numDays, grouped, lat, units, delta, climateNormal);
                    if (scores.length === 0) {
                        show("error", "No data to display.");
                        return;
                    }
                    var selectedInScores = scores.some(function(s) { return s.date === dateStr; });
                    if (!selectedInScores) {
                        show("error", "No data available for " + dateStr + " (timezone offset).");
                        return;
                    }

                    renderAll(scores, units, startYear, endYear, hideVars, dateStr, forecastWeatherCodes, forecastCurrent, forecastHourly);
                }
            );
        });
    });
}

/* ========== AUTO REFRESH ========== */
setInterval(function() { window.location.reload(); }, 3600000);

/* ========== INIT ========== */
var _initDone = false;
window.onload = function() {
    if (_initDone) return;
    _initDone = true;
    var params = parseUrlParams({});
    var loc = params["location"] || "";
    var lat = params["latitude"] || "";
    var lon = params["longitude"] || "";
    var rParam = params["rotation"] || "";
    var sParam = params["scale"] || "";

    /* Get current units - from URL, localStorage, or locale detection */
    if (params["units"]) {
        currentUnits = params["units"];
        setDefaultUnit(params["units"]);
    } else {
        currentUnits = getDefaultUnit();
        /* If this is the first visit (no stored unit), save the detected default */
        if (useCache) {
            try {
                if (!localStorage.getItem('unit')) {
                    setDefaultUnit(currentUnits);
                }
            } catch (e) {}
        }
    }

    currentDateStr = params["date"] || toISODate(new Date());

    var zoom = 1;
    if (sParam) {
        zoom = parseInt(sParam, 10) / 100;
        if (isNaN(zoom) || zoom <= 0) zoom = 1;
    }
    if (rParam) {
        hasRotation = true;
        setupRotation(rParam, zoom);
    } else if (zoom !== 1) {
        var el = document.getElementById("wrapper");
        if (el) el.style.zoom = zoom;
    }

    if (lat && lon) {
        locationName = loc || lat + ", " + lon;
        show("header", locationName);
        loadWeather(parseFloat(lat), parseFloat(lon), currentUnits, currentDateStr);
    } else if (loc) {
        var locCoords = parseCoords(loc);
        if (locCoords) {
            locationName = loc;
            show("header", loc);
            loadWeather(locCoords.lat, locCoords.lon, currentUnits, currentDateStr);
        } else {
            show("header", "Loading...");
            geocode(loc, function(err, gLat, gLon, name) {
                if (err) {
                    show("loading", "");
                    show("error", "Location not found: " + loc);
                    return;
                }
                locationName = name;
                show("header", name);
                loadWeather(parseFloat(gLat), parseFloat(gLon), currentUnits, currentDateStr);
            });
        }
    } else {
        function loadLisbon() {
            geocode("Lisbon, Portugal", function(err, gLat, gLon, name) {
                if (err) { show("error", "Location not found: Lisbon, Portugal"); return; }
                locationName = name;
                show("header", name);
                loadWeather(parseFloat(gLat), parseFloat(gLon), currentUnits, currentDateStr);
            });
        }
        if (navigator.geolocation) {
            show("header", "Detecting location...");
            show("loading", "Detecting location...");
            navigator.geolocation.getCurrentPosition(function(position) {
                var dLat = position.coords.latitude;
                var dLon = position.coords.longitude;
                locationName = dLat.toFixed(2) + ", " + dLon.toFixed(2);
                show("header", locationName);
                loadWeather(dLat, dLon, currentUnits, currentDateStr);
            }, function() {
                loadLisbon();
            });
        } else {
            loadLisbon();
        }
    }
};
</script>
</body>
</html>
