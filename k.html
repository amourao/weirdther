<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Weirdther</title>
<script src="weirdther-core.js"></script>
<style>
body { margin: 0; padding: 0; background: white; color: black; }
#wrapper { padding: 18px 22px; font-family: Helvetica, Arial, sans-serif; -webkit-box-sizing: border-box; box-sizing: border-box; overflow: hidden; }
#header { font-size: 42px; padding-bottom: 6px; border-bottom: 3px solid black; margin-bottom: 10px; }
.hdr-row { border: none; width: 100%; }
.hdr-row td { border: none; padding: 0; font-size: 42px; }
.hdr-right { text-align: right; white-space: nowrap; width: 1px; }
#loading { font-size: 48px; padding: 30px 0; }
#error { font-size: 48px; font-weight: bold; }
.progress-container { width: 100%; height: 60px; background: #ddd; border: 2px solid black; margin: 20px 0; position: relative; }
.progress-bar { height: 100%; background: black; width: 0%; transition: width 0.3s ease; }
.progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 36px; font-weight: bold; color: #333; }
/* Vars + Score side by side */
.vars-row { border: none; width: 100%; margin: 0; }
.vars-row td { border: none; padding: 0; vertical-align: top; }
.score-box { text-align: right; white-space: nowrap; padding-left: 12px; }
.score-num { font-size: 156px; font-weight: bold; line-height: 1; padding: 0 6px; }
.score-lbl { font-size: 66px; font-weight: bold; letter-spacing: 2px; padding: 0 6px; }
.score-num-inv { font-size: 156px; font-weight: bold; line-height: 1; padding: 0 6px; color: white; background: black; display: inline-block; }
.score-weirdther { font-size: 48px;}
.score-freq { font-size: 48px; color: #333; }
/* Variable breakdown */
table.vars { border-collapse: collapse; width: 100%; margin: 0; }
table.vars td { border: none; padding: 2px 6px; font-size: 52px; }
table.vars .vi { font-size: 54px; text-align: center; width: 56px; }
table.vars .pct { color: #333; text-align: right; }
table.vars .bld td { font-weight: bold; color: white; background: black; }
table.vars .bld-lo td { font-weight: bold; color: white; background: gray; }
/* Forecast */
table.fc { border-collapse: collapse; width: 100%; border: 2px solid black; }
table.fc th, table.fc td { border: none; padding: 5px 7px; text-align: right; font-size: 40px; }
table.fc th { background: #bbb; color: black; font-size: 36px; }
table.fc th:first-child, table.fc td:first-child { width: 1px; white-space: nowrap; padding: 5px 4px; }
table.fc .day-col { text-align: left; }
table.fc .icon-col { font-size: 46px; text-align: center; width: 48px; }
table.fc .bld { font-weight: bold; color: white; background: black; }
table.fc .bld-lo { font-weight: bold; color: white; background: gray; }
table.fc a { color: black; text-decoration: underline; }
/* Header controls */
.loc-form { margin: 0; padding: 0; width: 100%; white-space: nowrap; }
.loc-input { width: calc(100% - 80px); font-size: 36px; border: 1px solid gray; padding: 2px 6px; -webkit-box-sizing: border-box; box-sizing: border-box; vertical-align: top; }
.go-btn { width: 70px; font-size: 36px; border: 1px solid gray; padding: 2px 8px; vertical-align: top; margin-left: -4px; }
.score-refresh { font-size: 36px; color: #555; }
</style>
</head>
<body>
<div id="wrapper">
<div id="header"></div>
<div id="loading"></div>
<div id="error"></div>
<div id="results"></div>
</div>

<script>
/* ========== CONFIGURATION ========== */
var DAILY_VARS = "temperature_2m_max,temperature_2m_min,rain_sum,snowfall_sum,wind_speed_10m_max,sunshine_duration";
var VAR_LIST = DAILY_VARS.split(",");
var DEFAULT_DELTA = 5;
var NUM_FORECAST_DAYS = 6;
var HISTORICAL_YEARS = 26;
var SCORE_VARS = ["temperature_2m_max", "temperature_2m_min", "rain_sum", "snowfall_sum"];
var FRIENDLY = {
    "temperature_2m_max": {name: "Max", lower: "colder", higher: "warmer", metric: "&deg;C", imperial: "&deg;F"},
    "temperature_2m_min": {name: "Min", lower: "colder", higher: "warmer", metric: "&deg;C", imperial: "&deg;F"},
    "rain_sum": {name: "Rain", lower: "drier", higher: "rainier", metric: "mm", imperial: "in"},
    "snowfall_sum": {name: "Snow", lower: "less snowy", higher: "snowier", metric: "mm", imperial: "in"},
    "wind_speed_10m_max": {name: "Wind", lower: "calmer", higher: "windier", metric: "km/h", imperial: "mph"},
    "sunshine_duration": {name: "Sun", lower: "less sunny", higher: "sunnier", metric: "%", imperial: "%"}
};

var VAR_ICONS = {
    "temperature_2m_max": "&#9650;",
    "temperature_2m_min": "&#9660;",
    "rain_sum": "&#9730;",
    "snowfall_sum": "&#9731;",
    "wind_speed_10m_max": "&#8776;",
    "sunshine_duration": "&#9728;"
};

var currentLat = null;
var currentLon = null;
var currentUnits = "metric";
var currentDateStr = "";
var locationName = "";

/* ========== CACHE ========== */
var useCache = (function() {
    try {
        var t = "__wh_test__";
        localStorage.setItem(t, t);
        localStorage.removeItem(t);
        return true;
    } catch (e) {
        return false;
    }
})();

function getDefaultUnit() {
    if (!useCache) {
        var locale = navigator.language || navigator.userLanguage || "-";
        var country = locale.split('-')[1] || locale;
        var imperialCountries = ['US', 'LR', 'MM'];
        return imperialCountries.indexOf(country.toUpperCase()) !== -1 ? 'imperial' : 'metric';
    }
    try {
        var storedUnit = localStorage.getItem('unit');
        if (storedUnit) return storedUnit;
    } catch (e) {}
    var locale = navigator.language || navigator.userLanguage || "-";
    var country = locale.split('-')[1] || locale;
    var imperialCountries = ['US', 'LR', 'MM'];
    return imperialCountries.indexOf(country.toUpperCase()) !== -1 ? 'imperial' : 'metric';
}

function setDefaultUnit(unit) {
    if (!useCache) return;
    try {
        localStorage.setItem('unit', unit);
    } catch (e) {}
}

function cacheKey(dateStr, lat, lon, units) {
    return "historical-" + dateStr + "-" + lat + "-" + lon + "-" + units + ".json";
}

function clearTodayCache(lat, lon, units) {
    /* Only clear today's cache entry to allow fresh data updates */
    if (!useCache) return;
    try {
        var todayKey = cacheKey(toISODate(new Date()), lat, lon, units);
        localStorage.removeItem(todayKey);
    } catch (e) {}
}

/* ========== UTILITY ========== */

// parseUrlParams is provided by weirdther-core.js

function show(id, text) {
    var el = document.getElementById(id);
    if (!el) return;
    el.innerHTML = text;
    el.style.display = text ? "" : "none";
}

function showProgress(message, percent) {
    var el = document.getElementById("loading");
    if (!el) return;
    var pct = Math.round(percent);
    el.innerHTML = '<div>' + message + '</div>' +
        '<div class="progress-container">' +
        '<div class="progress-bar" style="width: ' + pct + '%"></div>' +
        '</div>';
    el.style.display = "";
}

function formatDateShort(dateStr) {
    var d = parseDate(dateStr);
    var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    return days[d.getDay()] + " " + d.getDate() + " " + months[d.getMonth()];
}

/* ========== HTTP ========== */

function httpGet(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
            if (xhr.status === 200) {
                try {
                    callback(null, JSON.parse(xhr.responseText));
                } catch (e) {
                    callback("JSON parse error", null);
                }
            } else {
                callback("HTTP error " + xhr.status, null);
            }
        }
    };
    xhr.send(null);
}

/* ========== API ========== */

function geocode(location, callback) {
    var url = "https://geocoding-api.open-meteo.com/v1/search?name=" + encodeURIComponent(location) + "&count=10&format=json";
    httpGet(url, function(err, data) {
        if (err || !data || !data.results || data.results.length === 0) {
            callback("Location not found");
            return;
        }
        var r = data.results[0];
        var name = r.name;
        if (r.admin1) name += ", " + r.admin1;
        if (r.country) name += ", " + r.country;
        callback(null, parseFloat(r.latitude).toFixed(2), parseFloat(r.longitude).toFixed(2), name);
    });
}


function fetchForecast(lat, lon, units, callback) {
    var url = "https://api.open-meteo.com/v1/forecast?forecast_days=16&past_days=1&latitude=" + lat + "&longitude=" + lon + "&daily=" + DAILY_VARS;
    var us = getUnitString(units);
    if (us) url += "&" + us;
    httpGet(url, callback);
}

function fetchHistoricalRange(lat, lon, startDate, endDate, units, callback) {
    var start = new Date(startDate);
    var end = new Date(endDate);
    var now = new Date();
    var today = toISODate(now);

    // Don't fetch future dates from archive API
    if (toISODate(end) > today) {
        end = now;
    }

    // If requesting only future dates, return null
    if (toISODate(start) > today) {
        console.log("Dates are in the future - forecast data will be used");
        callback(null, null);
        return;
    }

    // If start is after end, return null
    if (start > end) {
        callback(null, null);
        return;
    }

    var url = "https://archive-api.open-meteo.com/v1/archive?latitude=" + lat + "&longitude=" + lon +
              "&start_date=" + toISODate(start) + "&end_date=" + toISODate(end) + "&daily=" + DAILY_VARS;
    var us = getUnitString(units);
    if (us) url += "&" + us;

    console.log("Fetching historical range: " + toISODate(start) + " to " + toISODate(end));
    console.log("Archive API URL:", url);
    httpGet(url, function(err, data) {
        if (err) {
            console.log("Historical range fetch error:", err);
        } else if (data && data.daily) {
            console.log("Fetched historical data for dates:", data.daily.time);
            console.log("Sample data - temperature_2m_max:", data.daily.temperature_2m_max);
        } else {
            console.log("No historical data returned (archive API may not have recent data yet)");
        }
        callback(err, data);
    });
}

function fetchHistoricalYear(lat, lon, date, delta, year, units, callback) {
    var target = new Date(date.getTime());
    target.setFullYear(year);
    var startDate = new Date(target.getTime() - delta * 86400000);
    var endDate = new Date(target.getTime() + delta * 86400000);
    var now = new Date();
    if (startDate > now) { callback(null, null); return; }
    if (endDate > now) endDate = new Date(now.getTime() - 86400000);

    /* Check cache for each day in this range */
    if (useCache) {
        var allCached = true;
        var cachedData = {daily: {}};
        for (var k = 0; k < VAR_LIST.length; k++) cachedData.daily[VAR_LIST[k]] = [];
        cachedData.daily.time = [];

        for (var d = new Date(startDate.getTime()); d <= endDate; d.setDate(d.getDate() + 1)) {
            var key = cacheKey(toISODate(d), lat, lon, units);
            try {
                var cached = localStorage.getItem(key);
                if (cached) {
                    var dayData = JSON.parse(cached);
                    if (dayData && dayData.daily && dayData.daily.time && dayData.daily.time.length > 0) {
                        cachedData.daily.time.push(dayData.daily.time[0]);
                        for (var v = 0; v < VAR_LIST.length; v++) {
                            cachedData.daily[VAR_LIST[v]].push(dayData.daily[VAR_LIST[v]][0]);
                        }
                        continue;
                    }
                }
            } catch (e) {}
            allCached = false;
            break;
        }

        if (allCached && cachedData.daily.time.length > 0) {
            callback(null, cachedData);
            return;
        }
    }

    /* Fetch from API */
    var url = "https://archive-api.open-meteo.com/v1/archive?latitude=" + lat + "&longitude=" + lon +
        "&start_date=" + toISODate(startDate) + "&end_date=" + toISODate(endDate) + "&daily=" + DAILY_VARS;
    var us = getUnitString(units);
    if (us) url += "&" + us;
    httpGet(url, function(err, data) {
        if (err || !data) {
            callback(err, null);
            return;
        }

        /* Cache individual days */
        if (useCache && data && data.daily && data.daily.time) {
            try {
                for (var i = 0; i < data.daily.time.length; i++) {
                    var day = data.daily.time[i];
                    var key = cacheKey(day, lat, lon, units);
                    var dayData = JSON.parse(JSON.stringify(data));
                    dayData.daily = {};
                    for (var varName in data.daily) {
                        dayData.daily[varName] = [data.daily[varName][i]];
                    }
                    localStorage.setItem(key, JSON.stringify(dayData));
                }
                /* Clear today's cache to allow fresh updates */
                clearTodayCache(lat, lon, units);
            } catch (e) {}
        }

        callback(null, data);
    });
}

function fetchAllHistorical(lat, lon, date, delta, startYear, endYear, units, onProgress, callback) {

    /* Fetch all years sequentially */
    var results = [];

    // Cap endYear to current year, and exclude current year from historical comparison
    var currentYear = new Date().getFullYear();
    if (endYear > currentYear) {
        endYear = currentYear;
    }

    var total = endYear - startYear;

    function next(year) {
        if (year >= endYear) {  // Use >= to exclude endYear (current year)
            var grouped = groupAllHistorical(results);
            callback(null, grouped);
            return;
        }
        onProgress(year - startYear, total);
        fetchHistoricalYear(lat, lon, date, delta, year, units, function(err, data) {
            if (!err && data && data.daily && data.daily.time && data.daily.time.length > 0) {
                results.push(data);
            }
            next(year + 1);
        });
    }
    next(startYear);
}

/* ========== DATA PROCESSING ========== */

function allZero(arr) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] != null && arr[i] > 0) return false;
    }
    return true;
}

/**
 * Merges forecast and historical data, preferring historical when available
 * @param {Object} forecast - Forecast data {daily: {time: [], temp: [], ...}}
 * @param {Object} historical - Historical data {daily: {time: [], temp: [], ...}}
 * @returns {Object} Merged data in same format
 */
function mergeForecastHistorical(forecast, historical) {
    var merged = {daily: {}};
    var vars = VAR_LIST.slice();
    vars.push("time");

    console.log("Merging forecast (dates:", forecast.daily.time, ") with historical (dates:", historical && historical.daily ? historical.daily.time : "none", ")");

    // Start with forecast data
    for (var i = 0; i < vars.length; i++) {
        var varName = vars[i];
        merged.daily[varName] = forecast.daily[varName] ? forecast.daily[varName].slice() : [];
    }

    // Overwrite with historical data where available
    if (historical && historical.daily) {
        console.log("Historical data found - will merge", historical.daily.time.length, "days");
        for (var j = 0; j < historical.daily.time.length; j++) {
            var day = historical.daily.time[j];
            var offset = merged.daily.time.indexOf(day);

            if (offset === -1) {
                // Day not in forecast, add it
                console.log("Adding historical day not in forecast:", day);
                merged.daily.time.push(day);
                for (var k = 0; k < vars.length; k++) {
                    if (vars[k] !== "time") {
                        merged.daily[vars[k]].push(historical.daily[vars[k]] ? historical.daily[vars[k]][j] : null);
                    }
                }
            } else {
                // Day exists in forecast, overwrite with historical if non-null
                var overwriteCount = 0;
                for (var k = 0; k < vars.length; k++) {
                    if (vars[k] !== "time") {
                        var histVal = historical.daily[vars[k]] ? historical.daily[vars[k]][j] : null;
                        if (histVal != null) {
                            merged.daily[vars[k]][offset] = histVal;
                            overwriteCount++;
                        }
                    }
                }
                if (overwriteCount > 0) {
                    console.log("Merged historical data for", day, "- overwrote", overwriteCount, "values");
                }
            }
        }
    }

    // Sort by time
    var combined = [];
    for (var i = 0; i < merged.daily.time.length; i++) {
        var obj = {time: merged.daily.time[i]};
        for (var k = 0; k < vars.length; k++) {
            if (vars[k] !== "time") {
                obj[vars[k]] = merged.daily[vars[k]][i];
            }
        }
        combined.push(obj);
    }
    combined.sort(function(a, b) { return a.time < b.time ? -1 : (a.time > b.time ? 1 : 0); });

    // Reconstruct merged.daily from sorted combined
    for (var k = 0; k < vars.length; k++) {
        merged.daily[vars[k]] = [];
    }
    for (var i = 0; i < combined.length; i++) {
        for (var k = 0; k < vars.length; k++) {
            merged.daily[vars[k]].push(combined[i][vars[k]]);
        }
    }

    console.log("Merge complete - final dates:", merged.daily.time);
    console.log("Sample merged temperature_2m_max:", merged.daily.temperature_2m_max);

    return merged;
}


function computeAllDayScores(forecastDaily, todayIndex, numDays, historicalGrouped, latitude, units, delta, climateNormal) {
    delta = delta || WEIRDTHER_CONFIG.DEFAULT_DELTA;
    climateNormal = climateNormal || {start: 2000, end: 2030};

    var allScores = [];
    for (var d = 0; d < numDays; d++) {
        var idx = todayIndex + d;
        if (idx >= forecastDaily.time.length) break;

        var ds = {
            date: forecastDaily.time[idx],
            tempMax: forecastDaily.temperature_2m_max[idx],
            tempMin: forecastDaily.temperature_2m_min[idx],
            rain: forecastDaily.rain_sum[idx] || 0,
            snow: forecastDaily.snowfall_sum[idx] || 0,
            wind: forecastDaily.wind_speed_10m_max[idx] || 0,
            sunshineSec: forecastDaily.sunshine_duration[idx] || 0,
            sunshinePct: 0,
            weirdther: 0,
            maxPercentile: 0.5,
            vars: {}
        };

        var dlHours = getDaylightHours(ds.date, latitude);
        if (dlHours > 0) ds.sunshinePct = ds.sunshineSec / (dlHours * 3600);
        if (ds.sunshinePct > 1) ds.sunshinePct = 1;

        var maxScore = 0;
        var maxPctile = 0.5;

        for (var v = 0; v < VAR_LIST.length; v++) {
            var varName = VAR_LIST[v];
            var curVal = forecastDaily[varName][idx];
            if (curVal == null) continue;

            // Filter historical data by day-of-year window and climate normal years
            var filtered = filterHistoricalByDateWindow(
                historicalGrouped[varName],
                historicalGrouped["time"],
                ds.date,
                delta,
                climateNormal
            );

            if (d === 0) {
                console.log("[" + varName + "] First day: " + ds.date + ", value: " + curVal + ", comparing against " + filtered.values.length + " historical values");
            }

            var result = computeVariableScore(varName, filtered.values, filtered.dates, curVal, ds.date, latitude);

            if (d === 0) {
                console.log("[" + varName + "] Result - percentile: " + (result.percentile * 100).toFixed(1) + "%, score: " + result.score.toFixed(2));
            }

            if (filtered.values.length === 0) continue;

            var pctile = result.percentile;
            var score = result.score;
            var cmpVal = result.normalizedValue;

            var qualifier = "";
            if (pctile < 0) qualifier = FRIENDLY[varName].lower + "!";
            else if (pctile > 1) qualifier = FRIENDLY[varName].higher + "!";
            else if (pctile < 0.05) qualifier = "very " + FRIENDLY[varName].lower;
            else if (pctile > 0.95) qualifier = "very " + FRIENDLY[varName].higher;
            else if (pctile < 0.25) qualifier = FRIENDLY[varName].lower;
            else if (pctile > 0.75) qualifier = FRIENDLY[varName].higher;

            var dispPctile = pctile;
            if (dispPctile < 0) dispPctile = 0;
            if (dispPctile > 1) dispPctile = 1;

            var dispValue = curVal;
            if (varName === "sunshine_duration") dispValue = ds.sunshinePct;

            ds.vars[varName] = {
                raw: dispPctile,
                score: score,
                qualifier: qualifier,
                value: dispValue
            };

            if (isScoreVar(varName) && score > maxScore) {
                maxScore = score;
                maxPctile = Math.abs(pctile - 0.5) + 0.5;
            }
        }

        ds.weirdther = Math.round(maxScore * 100);
        if (ds.weirdther > 100) ds.weirdther = 100;
        if (ds.weirdther === 100) ds.weirdther = 99;
        ds.maxPercentile = maxPctile;
        allScores.push(ds);
    }
    return allScores;
}

/* ========== RENDERING ========== */


function buildPageUrl(overrides) {
    var params = parseUrlParams();
    var keys = ["location", "latitude", "longitude", "units", "date", "rotation", "scale"];
    var i, k;
    for (i = 0; i < keys.length; i++) {
        k = keys[i];
        if (overrides[k] !== undefined) params[k] = overrides[k];
    }

    var qs = buildUrlQuery(params, keys);
    return window.location.pathname + qs;
}

function goLocation() {
    var inp = document.getElementById("loc-input");
    if (!inp || !inp.value) return;
    window.location.href = buildPageUrl({"location": inp.value, "latitude": "", "longitude": "", "date": ""});
}

function formatTime(d) {
    var h = d.getHours();
    var m = d.getMinutes();
    var day = d.getDate();
    var month = d.getMonth() + 1;
    var year = d.getFullYear();
    return year + "-" + (month < 10 ? "0" : "") + month + "-" + (day < 10 ? "0" : "") + day + " " +
           (h < 10 ? "0" : "") + h + ":" + (m < 10 ? "0" : "") + m;
}

function buildDateLink(dateStr) {
    var params = parseUrlParams();
    params.date = dateStr;
    var keys = ["location", "latitude", "longitude", "units", "rotation", "scale", "date"];
    return buildUrlQuery(params, keys);
}

function fmtVal(varName, value, units) {
    if (varName === "sunshine_duration") return Math.round(value * 100) + "%";
    if (varName === "temperature_2m_max" || varName === "temperature_2m_min") return Math.round(value) + FRIENDLY[varName][units];
    if (varName === "wind_speed_10m_max") return Math.round(value) + FRIENDLY[varName][units];
    return (value != null ? value.toFixed(1) : "0") + FRIENDLY[varName][units];
}

function renderAll(dayScores, units, startYear, endYear, hideVars, selectedDate) {
    var html = "";
    var nowStr = toISODate(new Date());

    // Find the selected day in dayScores (may not be index 0 if yesterday is included)
    var selectedIdx = 0;
    for (var si = 0; si < dayScores.length; si++) {
        if (dayScores[si].date === selectedDate) { selectedIdx = si; break; }
    }
    var today = dayScores[selectedIdx];

    var isToday = (today.date === nowStr);
    var wx = getWeather(today.rain, today.snow, today.sunshinePct, today.wind, units);
    var label = getScoreLabel(today.weirdther);
    var dateLabel = isToday ? "Today" : formatDateShort(today.date);
    var hideRain = !!hideVars["rain_sum"];
    var hideSnow = !!hideVars["snowfall_sum"];

    /* ---- Update header: location input left, units+weather right ---- */
    var escapedName = locationName.replace(/"/g, '&quot;');
    var metricUrl = buildPageUrl({"units": "metric"});
    var imperialUrl = buildPageUrl({"units": "imperial"});
    var unitC = units === "metric" ? "<b>C</b>" : '<a href="' + metricUrl + '">C</a>';
    var unitF = units === "imperial" ? "<b>F</b>" : '<a href="' + imperialUrl + '">F</a>';
    show("header", '<table class="hdr-row"><tr>' +
        '<td><form onsubmit="goLocation();return false;" class="loc-form"><input id="loc-input" class="loc-input" value="' + escapedName + '"><input type="submit" value="Go" class="go-btn"></form></td>' +
        '<td class="hdr-right">' + unitC + '|' + unitF + ' ' + wx.icon + ' ' + dateLabel + '</td>' +
        '</tr></table>');

    /* ---- Vars left, score right ---- */
    html += '<table class="vars-row"><tr><td>';

    html += '<table class="vars">';
    for (var v = 0; v < VAR_LIST.length; v++) {
        var vn = VAR_LIST[v];
        if (hideVars[vn]) continue;
        var vi = today.vars[vn];
        if (!vi) continue;
        var cls = unusualClass(vi.raw);
        html += '<tr' + (cls ? ' class="' + cls + '"' : '') + '>';
        html += '<td class="vi">' + VAR_ICONS[vn] + '</td>';
        html += '<td>' + fmtVal(vn, vi.value, units) + '</td>';
        html += '<td class="pct">' + pctPretty(vi.raw) + '</td>';
        html += '</tr>';
    }
    html += '</table>';

    html += '</td><td class="score-box">';
    html += '<div class="score-weirdther">WEIRDTHER</div>';
    if (today.weirdther >= 75) {
        html += '<div><span class="score-num-inv">' + today.weirdther + '</span></div>';
    } else {
        html += '<div class="score-num">' + today.weirdther + '</div>';
    }
    html += '<div class="score-lbl">' + label + '</div>';
    // html += '<div class="score-freq">' + genOnceEvery(today.maxPercentile, startYear, endYear) + '</div>';
    html += '<div class="score-refresh">' + formatTime(new Date()) + '</div>';
    html += '</td></tr></table>';

    /* ---- Forecast table with values, clickable days ---- */
    html += '<table class="fc">';
    html += '<tr><th></th><th class="day-col">Day</th><th>&#9650;</th><th>&#9660;</th>';
    if (!hideRain) html += '<th>&#9730;</th>';
    if (!hideSnow) html += '<th>&#9731;</th>';
    html += '<th><b>&#8776;</b></th><th>&#9728;</th><th>W</th></tr>';

    for (var d = 0; d < dayScores.length; d++) {
        var ds = dayScores[d];
        var isSelectedRow = (ds.date === selectedDate);
        var isActualToday = (ds.date === nowStr);
        var dayLabel = isActualToday ? "Today" : formatDateShort(ds.date);
        var rwx = getWeather(ds.rain, ds.snow, ds.sunshinePct, ds.wind, units);
        var link = buildDateLink(ds.date);

        var cTempMax = ds.vars["temperature_2m_max"] ? unusualClass(ds.vars["temperature_2m_max"].raw) : "";
        var cTempMin = ds.vars["temperature_2m_min"] ? unusualClass(ds.vars["temperature_2m_min"].raw) : "";
        var cWind = ds.vars["wind_speed_10m_max"] ? unusualClass(ds.vars["wind_speed_10m_max"].raw) : "";
        var cSun = ds.vars["sunshine_duration"] ? unusualClass(ds.vars["sunshine_duration"].raw) : "";
        var sunPct = Math.round(ds.sunshinePct * 100) + "%";

        html += '<tr' + (isSelectedRow ? ' style="border-top:2px solid #000;border-bottom:2px solid #000"' : '') + '>';
        html += '<td class="icon-col">' + rwx.icon + '</td>';
        html += '<td class="day-col"><a href="' + link + '"' + (isSelectedRow ? ' style="font-weight:bold"' : '') + '>' + dayLabel + '</a></td>';
        html += '<td' + (cTempMax ? ' class="' + cTempMax + '"' : '') + '>' + Math.round(ds.tempMax) + '</td>';
        html += '<td' + (cTempMin ? ' class="' + cTempMin + '"' : '') + '>' + Math.round(ds.tempMin) + '</td>';
        if (!hideRain) {
            var cRain = ds.vars["rain_sum"] ? unusualClass(ds.vars["rain_sum"].raw) : "";
            html += '<td' + (cRain ? ' class="' + cRain + '"' : '') + '>' + ds.rain.toFixed(1) + '</td>';
        }
        if (!hideSnow) {
            var cSnow = ds.vars["snowfall_sum"] ? unusualClass(ds.vars["snowfall_sum"].raw) : "";
            html += '<td' + (cSnow ? ' class="' + cSnow + '"' : '') + '>' + ds.snow.toFixed(1) + '</td>';
        }
        html += '<td' + (cWind ? ' class="' + cWind + '"' : '') + '>' + Math.round(ds.wind) + '</td>';
        html += '<td' + (cSun ? ' class="' + cSun + '"' : '') + '>' + sunPct + '</td>';
        html += '<td' + (ds.weirdther >= 75 ? ' class="bld"' : '') + '>' + ds.weirdther + '</td>';
        html += '</tr>';
    }
    html += '</table>';

    show("results", html);
}

/* ========== ROTATION ========== */

function setupRotation(angle, zoom) {
    var deg = parseInt(angle, 10);
    if (isNaN(deg)) return;
    if (!zoom || zoom <= 0) zoom = 1;
    var el = document.getElementById("wrapper");
    if (!el) return;
    var w = window.innerWidth || document.documentElement.clientWidth || screen.width || 600;
    var h = window.innerHeight || document.documentElement.clientHeight || screen.height || 800;
    /* For 90/270 rotation, swap and scale wrapper dimensions */
    var a = Math.abs(deg % 360);
    if (a === 90 || a === 270) {
        var wrapW = Math.round(h / zoom);
        var wrapH = Math.round(w / zoom);
        el.style.width = wrapW + "px";
        el.style.height = wrapH + "px";
        el.style.position = "absolute";
        el.style.left = Math.round((w - wrapW) / 2) + "px";
        el.style.top = Math.round((h - wrapH) / 2) + "px";
        el.style.overflow = "hidden";
    }
    var xf = "rotate(" + deg + "deg)";
    if (zoom !== 1) xf += " scale(" + zoom + ")";
    el.style.webkitTransformOrigin = "50% 50%";
    el.style.webkitTransform = xf;
    el.style.transformOrigin = "50% 50%";
    el.style.transform = xf;
}

/* ========== MAIN FLOW ========== */

function loadWeather(lat, lon, units, dateStr) {
    currentLat = lat;
    currentLon = lon;
    currentUnits = units;
    currentDateStr = dateStr;
    var date = parseDate(dateStr);
    var delta = DEFAULT_DELTA;
    var endYear = 2030;  // Match app.js climate normal
    var startYear = 2001;  // Match app.js climate normal

    show("error", "");
    show("results", "");
    show("loading", "Loading forecast...");

    fetchForecast(lat, lon, units, function(err, forecast) {
        if (err || !forecast || !forecast.daily) {
            show("loading", "");
            show("error", "Error loading forecast: " + (err || "no data"));
            return;
        }

        var todayIdx = -1;
        for (var i = 0; i < forecast.daily.time.length; i++) {
            if (forecast.daily.time[i] === dateStr) { todayIdx = i; break; }
        }
        if (todayIdx === -1) {
            show("error", "Date " + dateStr + " not found in forecast.");
            return;
        }

        showProgress("Loading current weather...", 10);

        // Fetch historical data for the forecast date range to get actual values
        // Note: Archive API has ~5 day delay, so forecast API data is used for recent dates
        // Include yesterday in the range if available (for yesterday row)
        var rangeStartIdx = todayIdx > 0 ? todayIdx - 1 : todayIdx;
        var forecastStart = forecast.daily.time[rangeStartIdx];
        var forecastEnd = forecast.daily.time[Math.min(todayIdx + NUM_FORECAST_DAYS - 1, forecast.daily.time.length - 1)];

        fetchHistoricalRange(lat, lon, forecastStart, forecastEnd, units, function(err, currentHistorical) {
            showProgress("Loading historical data for comparison...", 30);
            if (!currentHistorical) {
                console.log("Using forecast data for current dates (archive API not available for recent dates)");
            }

            // Use selected date as center, but fetch wider range to cover all forecast dates
            // Each forecast day will use its own ±delta window from this wider dataset
            var widerDelta = delta + NUM_FORECAST_DAYS - 1;  // Cover selected ±delta + all forecast days
            console.log("Historical data: center=" + dateStr + ", widerDelta=" + widerDelta + " (covers all forecast dates " + forecastStart + " to " + forecastEnd + ")");

            fetchAllHistorical(lat, lon, date, widerDelta, startYear, endYear, units,
                function(done, total) {
                    showProgress("Loading historical data...", 30 + (done / total) * 70);
                },
                function(err, grouped) {
                    show("loading", "");
                    if (err || !grouped || !grouped.time || grouped.time.length === 0) {
                        show("error", "Error loading historical data.");
                        return;
                    }

                    // Merge forecast with historical data for current dates
                    var mergedForecast = mergeForecastHistorical(forecast, currentHistorical);

                    // Re-find today's index in merged data
                    todayIdx = -1;
                    for (var i = 0; i < mergedForecast.daily.time.length; i++) {
                        if (mergedForecast.daily.time[i] === dateStr) { todayIdx = i; break; }
                    }
                    if (todayIdx === -1) {
                        show("error", "Date " + dateStr + " not found in merged data.");
                        return;
                    }

                    /* Hide precip vars only if all zero in forecast AND zero is >= P50 historically */
                    var hideVars = {};
                    var precipVars = ["rain_sum", "snowfall_sum"];
                    for (var pv = 0; pv < precipVars.length; pv++) {
                        var pvn = precipVars[pv];
                        var fcAllZero = true;
                        for (var fi = todayIdx; fi < todayIdx + NUM_FORECAST_DAYS && fi < mergedForecast.daily.time.length; fi++) {
                            if ((mergedForecast.daily[pvn][fi] || 0) > 0) { fcAllZero = false; break; }
                        }
                        if (fcAllZero) {
                            var hist = [];
                            for (var hi = 0; hi < grouped[pvn].length; hi++) {
                                if (grouped[pvn][hi] != null) hist.push(grouped[pvn][hi]);
                            }
                            hist.sort(function(a, b) { return a - b; });
                            var zeroPct = hist.length > 0 ? findPercentileForValue(hist, 0) : 0.5;
                            if (zeroPct[0] >= 0.5) hideVars[pvn] = true;
                        }
                    }

                    var delta = WEIRDTHER_CONFIG.DEFAULT_DELTA;
                    var climateNormal = {start: startYear, end: endYear};
                    console.log("Climate normal range:", climateNormal);
                    console.log("Historical data year range:", grouped.time[0], "to", grouped.time[grouped.time.length - 1]);
                    console.log("Total historical days:", grouped.time.length);
                    // Include yesterday only when selected day is today or in the future
                    var isSelectedTodayOrFuture = (dateStr >= toISODate(new Date()));
                    var startIdx = (isSelectedTodayOrFuture && todayIdx > 0) ? todayIdx - 1 : todayIdx;
                    var numDays = NUM_FORECAST_DAYS + ((isSelectedTodayOrFuture && todayIdx > 0) ? 1 : 0);
                    console.log("Score computation: dateStr=" + dateStr + ", todayIdx=" + todayIdx + ", startIdx=" + startIdx + ", numDays=" + numDays + ", isSelectedTodayOrFuture=" + isSelectedTodayOrFuture);
                    console.log("Merged forecast dates:", mergedForecast.daily.time);
                    var scores = computeAllDayScores(mergedForecast.daily, startIdx, numDays, grouped, lat, units, delta, climateNormal);
                    if (scores.length === 0) {
                        show("error", "No data to display.");
                        return;
                    }

                    renderAll(scores, units, startYear, endYear, hideVars, dateStr);
                }
            );
        });
    });
}

/* ========== AUTO REFRESH ========== */
setInterval(function() { window.location.reload(); }, 3600000);

/* ========== INIT ========== */
window.onload = function() {
    var params = parseUrlParams({"location": "Lisbon, Portugal"});
    var loc = params["location"] || "";
    var lat = params["latitude"] || "";
    var lon = params["longitude"] || "";
    var rParam = params["rotation"] || "";
    var sParam = params["scale"] || "";

    /* Get current units - from URL, localStorage, or locale detection */
    if (params["units"]) {
        currentUnits = params["units"];
        setDefaultUnit(params["units"]);
    } else {
        currentUnits = getDefaultUnit();
        /* If this is the first visit (no stored unit), save the detected default */
        if (useCache) {
            try {
                if (!localStorage.getItem('unit')) {
                    setDefaultUnit(currentUnits);
                }
            } catch (e) {}
        }
    }

    currentDateStr = params["date"] || toISODate(new Date());

    var zoom = 1;
    if (sParam) {
        zoom = parseInt(sParam, 10) / 100;
        if (isNaN(zoom) || zoom <= 0) zoom = 1;
    }
    if (rParam) {
        hasRotation = true;
        setupRotation(rParam, zoom);
    } else if (zoom !== 1) {
        var el = document.getElementById("wrapper");
        if (el) el.style.zoom = zoom;
    }

    if (lat && lon) {
        locationName = loc || lat + ", " + lon;
        show("header", locationName);
        loadWeather(parseFloat(lat), parseFloat(lon), currentUnits, currentDateStr);
    } else if (loc) {
        show("header", "Loading...");
        geocode(loc, function(err, gLat, gLon, name) {
            if (err) {
                show("loading", "");
                show("error", "Location not found: " + loc);
                return;
            }
            locationName = name;
            show("header", name);
            loadWeather(parseFloat(gLat), parseFloat(gLon), currentUnits, currentDateStr);
        });
    } else {
        show("header", "WEIRDTHER");
        show("loading", "Add ?location=City to the URL");
    }
};
</script>
</body>
</html>
